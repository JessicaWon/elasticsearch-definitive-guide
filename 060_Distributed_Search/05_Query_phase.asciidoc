=== 搜索阶段
在最初阶段 _query phase_ 时， ((("distributed search execution", "query phase"))) ((("query phase of distributed search"))) 搜索是广播查询索引中的每一个分片复本，不管是主本还是副本。每个分片执行本地查询，同时 ((("priority queue"))) 创建文档命中后的 _priority queue_ 。

.优先队列
****
_priority queue_ 仅仅是一个含有命中文档的 _top-n_ 过滤后列表。优先队列的大小取决于分页参数 `from` 和 `size` 。例如，如下搜索请求将需要足够大的优先队列来放入100条文档。

[source,js]
--------------------------------------------------
GET /_search
{
    "from": 90,
    "size": 10
}
--------------------------------------------------
****

查询过程在 <<img-distrib-search>> 中有描述。

[[img-distrib-search]]
.Query phase of distributed s
.查询过程分布式搜索
image::images/elas_0901.png["查询过程分布式搜索"]

查询过程包含以下几个步骤:

1. 客户端发送 `search` 请求到 `Node 3`，会差生一个大小为 `from + size` 的空优先队列。

2. `Node 3` 将查询请求前转到每个索引的每个分片中的主本或复本去。每个分片执行本地查询并添加结果到大小为 `from + size` 的本地优先队列中。

3. 每个分片返回文档的IDs并且将所有优先队列中文档归类到对应的节点， `Node 3` 合并这些值到其优先队列中来产生一个全局排序后的列表。

当查询请求到达节点的时候，节点变成了并列节点。 ((("nodes", "coordinating node for search requests"))) 这个节点任务是广播查询请求到所有相关节点并收集其他节点的返回状态存入全局排序后的集合，状态最终可以返回到客户端。

第一步是广播请求到索引中的每个几点钟一个分片复本去。就像 <<distrib-read,document `GET` requests>> 查询请求可以被某个主分片或其副本处理， ((("shards", "handling search requests"))) 则是在结合硬件的时候处理多个复本如何增加查询吞吐率。一个并列节点将在之后的请求中轮询所有的分片复本来分散负载。

每个分片在本地执行查询请求并且创建一个长度为 `from + size`&#x2014 的优先队列；换句话说，它自己的查询结果来满足全局查询请求，它返回一个轻量级的结果列表到并列节点上，其中并列节点仅包含文档IDs和排序的任何值，比如 `_score` 。

并列节点合并了这些分片段到其排序后的优先队列，这些队列代表着全局排序结果集合，以下是查询过程结束。

[NOTE]
====
一个索引可被一个或几个主分片组成， ((("indices", "multi-index search"))) 所以一条搜索请求到单独的索引时需要参考多个分片。除了涉及到更多的分片， _multiple_ 或者 _all_ 索引搜索工作方式是一样的。
====
